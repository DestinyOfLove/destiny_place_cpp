# 线程安全定长内存池 - 线程本地缓存 (Thread-Local Cache)

## 核心思想

这是线程安全优化的第三个版本，旨在通过**减少线程间同步**来达到极致的性能。前两个版本（Mutex 和 Lock-Free）都需要在多个线程间同步同一个共享资源（`free_list_head_`），而此版本的设计目标是让绝大多数操作完全不需要同步。

其核心思想是**空间换时间**：

1.  **中央池 (Central Pool)**：系统内依旧维护一个全局的、线程安全的内存池。这个池可以使用前一阶段的无锁版本，以保证高效的全局分配。

2.  **线程本地缓存 (Thread-Local Cache)**：使用 C++ 的 `thread_local` 关键字，为每一个线程创建一个私有的空闲链表头指针 `local_free_list_`。这个链表是该线程独享的，对它的任何读写操作都**不存在数据竞争**，因此完全不需要任何锁或原子操作。

3.  **`allocate()` 逻辑**：
    *   当需要分配内存时，首先检查线程本地的 `local_free_list_` 是否有空闲块。
    *   如果有，直接从本地链表取下一个块并返回。这是一个极快的、无竞争的操作。
    *   如果本地链表为空，则会向中央池“批发”一批内存块（例如 32 个），并把它们链接到本地链表上。这个“批发”操作才会发生线程间同步。
    *   之后，再从填充好的本地链表中取出一个块返回。

4.  **`deallocate()` 逻辑**：
    *   当释放内存时，直接将块链接到线程本地的 `local_free_list_` 头部。这同样是一个无竞争的、极快的操作。

## 优点

*   **极致的性能**：绝大多数（在一个批发的周期内）的 `allocate` 和 `deallocate` 操作都是在无竞争的线程本地内存上完成的，其速度接近于简单的指针移动，吞吐量极高。
*   **无锁竞争**：只有当本地缓存耗尽，需要从中央池补充时，才会发生同步。大大降低了线程间争用的频率。

## 缺点

*   **内存占用更高**：内存块可能会暂时被“困”在某个不活跃线程的本地缓存中，而无法被其他急需内存的线程使用，导致系统的整体内存利用率下降，峰值内存占用更高。
*   **实现更复杂**：需要管理中央池和线程本地池之间的交互。此外，当线程退出时，其本地缓存中的内存块如何安全地归还给中央池，是一个需要小心处理的复杂问题（本基础实现未处理此回收逻辑）。
