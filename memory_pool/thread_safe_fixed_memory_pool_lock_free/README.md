# 线程安全定长内存池 - 无锁版本 (Lock-Free)

## 核心思想

本版本是线程安全优化的第二步，旨在通过**无锁编程**技术，消除互斥锁带来的性能瓶颈。

其核心是利用现代 CPU 提供的**原子操作 (Atomic Operations)**，特别是 CAS (Compare-And-Swap)，来安全地修改共享数据。

1.  **`std::atomic<FreeBlock*>`**：将空闲链表的头指针 `free_list_head_` 声明为 `std::atomic` 类型。这保证了对该指针的所有读、写操作都是原子的，不会在执行中途被其他线程打断。

2.  **`allocate()` - 无锁弹栈**：
    *   使用 `compare_exchange_weak` (CAS) 来实现。这是一个循环操作：
    1.  原子性地读取当前的 `head`。
    2.  计算出期望的下一个 `head` (即 `head->next`)。
    3.  调用 `compare_exchange_weak`，尝试将当前的 `head` 原子性地替换为 `head->next`。
    *   只有当 `head` 在此期间没有被其他线程修改过时，替换才会成功。如果被修改了，操作失败，循环会重试，直到成功为止。

3.  **`deallocate()` - 无锁压栈**：
    *   同样使用 `compare_exchange_weak` 实现：
    1.  将要释放的块的 `next` 指针指向当前的 `head`。
    2.  尝试将 `head` 原子性地更新为这个新释放的块。
    *   这个过程同样在循环中进行以保证成功。

## 优点

*   **高性能**：避免了线程阻塞和昂贵的内核态上下文切换。线程在发生争用时，只是进行几次空转重试（spin），而不是被挂起。在高并发、低争用的场景下，性能远超基于锁的实现。
*   **高并发性**：允许多个线程真正地同时访问内存池，充分利用多核 CPU 的能力。

## 缺点与挑战

*   **ABA 问题**：这是无锁编程中的一个经典问题。虽然在本实现中，ABA 问题不会导致内存损坏（因为即使一个块被分配后又被释放回来，其内容无关紧要），但在更复杂的无锁数据结构中，这可能是一个严重的问题，通常需要更复杂的解决方案（如带标记的指针）。
*   **复杂性**：无锁编程的逻辑比使用锁更复杂，难以编写和调试。需要对内存模型（Memory Model）有深刻的理解。
*   **高争用下的性能**：在极度争用的情况下，大量线程可能会持续地空转重试，消耗大量 CPU 时间，性能反而可能不如锁（因为锁会将失败的线程置于休眠状态，让出 CPU）。
