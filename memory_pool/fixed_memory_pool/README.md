# 定长内存池 (Fixed-Size Memory Pool)

## 核心思想

`FixedSizeMemoryPool` 是一个基础的内存池，旨在通过预先分配一大块连续内存，并将其分割成固定大小的块（block）来提升内存分配和释放的性能。

其核心设计如下：
1.  **预分配内存**：在构造时，内存池通过一次 `malloc` 调用，向操作系统申请一块能容纳 `N` 个块的连续内存。
2.  **空闲链表 (Free List)**：所有内存块通过一个单向链表（称为“空闲链表”）连接起来。`free_list_head_` 指针指向链表头。每个空闲块的内存空间被用来存储一个指向下一个空闲块的指针。
3.  **分配 (allocate)**：分配操作非常高效。它从空闲链表头部取下一个节点（弹栈操作），并将其指针返回给用户。这是一个 O(1) 操作。
4.  **释放 (deallocate)**：释放操作同样高效。它将被用户归还的内存块重新插入到空闲链表的头部（压栈操作）。这也是一个 O(1) 操作。

这种设计避免了频繁调用 `malloc` 和 `free` 所带来的昂贵系统调用开销，并从根本上消除了内存碎片问题（因为所有块大小相同）。

## 当前版本的局限性

这个基础实现虽然高效，但存在以下显著局限性：

1.  **单一尺寸 (Single Size)**：一个内存池实例只能分配一种固定大小的内存块。如果需要多种尺寸，必须创建多个实例，管理复杂。
2.  **无法扩容 (No Auto-Scaling)**：内存池的大小在创建时就已固定。如果所有块都被分配，后续的分配请求将失败（返回 `nullptr`），无法动态满足增长的需求。
3.  **非线程安全 (Not Thread-Safe)**：对空闲链表头 `free_list_head_` 的读写没有进行任何同步保护。在多线程环境下，并发的 `allocate` 和 `deallocate` 会导致数据竞争，极易破坏链表结构，引发程序崩溃。
4.  **内存对齐 (Alignment)**：
    *   实现未考虑需要特定对齐（如 SSE/AVX 指令集要求的 16/32 字节对齐）的数据结构。
    *   当请求的 `block_size` 小于一个指针的大小时，`FreeBlock` 的 `next` 指针会越界写入，破坏相邻内存块的数据。
5.  **健壮性不足 (Lack of Robustness)**：
    *   构造函数中的 `malloc` 失败时没有进行错误检查。
    *   `deallocate` 时无法验证传入的指针是否真的属于该内存池，错误的释放可能导致整个池被污染。

这些局限性是后续版本优化的重点。
