# 内存池基准测试设计文档 (Benchmark Design)

## 1. 测试目标

此基准测试旨在全面、公平、可信地评估不同内存池实现的性能。测试不仅关注极限吞吐量，还涵盖多个维度，以模拟真实世界的应用场景，并为不同实现之间的权衡（trade-offs）提供量化依据。

核心目标是回答以下问题：
*   相比系统默认的 `malloc`/`free`，我们的内存池在哪些场景下有优势？
*   不同的线程安全策略（Mutex、Lock-Free、Thread-Local）在不同并发和竞争水平下表现如何？
*   通用内存池 (`GeneralMemoryPool`) 的额外开销（尺寸映射、元数据）在实践中有多大影响？
*   哪个实现在延迟（Latency）方面表现最好？

## 2. 关键评测维度

为了避免上一版测试的片面性，本次测试将围绕以下几个核心维度展开：

### 2.1. 分配尺寸组合 (Allocation Size Mix)
*   **目的**：评估内存池处理不同大小请求的能力，特别是通用池的尺寸映射效率和内部碎片影响。
*   **场景**：
    1.  **固定小尺寸 (Fixed Small)**: 所有请求均为 32 字节。用于与旧版测试对比，并评估纯粹的并发性能。
    2.  **固定大尺寸 (Fixed Large)**: 所有请求均为 256 字节。观察大对象分配的性能。
    3.  **混合尺寸 (Mixed Sizes)**: 请求的尺寸在一系列预设值（如 `[16, 32, 64, 128, 256]`）中随机选择。这是对通用池最真实的考验。

### 2.2. 对象生命周期与竞争强度 (Object Lifetime & Contention)
*   **目的**：模拟真实应用中内存的动态使用模式，并评估不同锁策略在不同竞争水平下的表现。
*   **场景**：
    1.  **高频同步 (High Contention)**: 线程循环执行 `allocate` -> `deallocate`，中间几乎没有其他工作。这会最大化对内存池的竞争。
    2.  **中频同步 (Medium Contention)**: 在 `allocate` 和 `deallocate` 之间，线程会执行少量模拟工作（例如，对分配的内存进行读写操作）。
    3.  **低频同步 (Low Contention)**: 在内存操作之间，线程执行更多的模拟工作。这代表了计算密集型应用中的内存使用模式。

### 2.3. 核心性能指标 (Metrics)
*   **吞吐量 (Throughput)**: 每秒完成的操作数（一次 `allocate` + 一次 `deallocate` 记为两次操作）。这是衡量总体性能的关键指标。
*   **p99 延迟 (99th Percentile Latency)**: 测量并记录每次 `allocate` 的耗时，并计算 99% 的操作都低于哪个时间值。这对于评估性能的稳定性、发现“毛刺”至关重要。
*   **内存开销 (Memory Overhead)**: (手动测量) 在特定测试场景结束后，通过外部工具观察进程的峰值物理内存占用（RSS），与理论分配的总量进行比较。

## 3. 测试设计与实现

1.  **引入基线 (Baseline)**: 所有测试场景都**必须**包含一个使用系统 `malloc`/`free` 的基准测试，作为性能比较的“黄金标准”。

2.  **测试框架结构**:
    *   设计一个可配置的 `BenchmarkRunner` 类。
    *   通过参数控制**线程数**、**每个线程的分配次数**、**尺寸分布策略**和**工作负载强度**。
    *   在 `main` 函数中，组合这些参数，依次运行所有内存池实现和 `malloc` 基线。

3.  **预热阶段 (Warm-up)**: 在正式计时前，每个测试线程都会先执行一定数量（例如 10%）的“预热”操作。这些操作不计入最终结果，目的是为了让 CPU 缓存、线程本地缓存等达到稳定状态。

4.  **延迟测量**: 在测试循环中，使用 `std::chrono::high_resolution_clock` 记录每次 `allocate` 前后的时间点，计算差值，并将结果存入一个大的 `std::vector<double>` 中。测试结束后，对该向量排序，取 99% 位置的值作为 p99 延迟。

5.  **报告生成**: 
    *   在所有测试运行完毕后，打印一份结构清晰的 Markdown 格式表格。
    *   表格的每一行代表一个测试运行（一个实现 + 一个场景）。
    *   列应包括：`Implementation`, `Threads`, `Size-Mix`, `Contention`, `Throughput (Ops/sec)`, `p99 Latency (ns)`。
    *   在报告的最上方，自动或手动包含测试环境的关键信息（CPU、OS、编译器）。

## 4. 预期结果分析

*   **Mutex vs. Lock-Free**: 在高竞争下，Lock-Free 可能会因自旋而性能更差；但在中低竞争下，Lock-Free 应该会胜出。
*   **Thread-Local**: 在所有固定尺寸的场景中，无论竞争强度如何，Thread-Local 都应该是性能最好的，因为绝大多数操作无锁。
*   **General-Purpose**: 在混合尺寸场景下，其性能应略低于 Thread-Local，但远高于 Mutex 和 Lock-Free。其 p99 延迟可能会因为尺寸判断和元数据操作而稍高。
*   **malloc**: `malloc` 是一个高度优化的通用分配器，很可能在多线程和混合尺寸场景下表现得非常有竞争力，甚至可能超过我们的一些简单实现。
