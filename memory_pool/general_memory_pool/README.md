# 通用内存池 (General-Purpose Memory Pool)

## 核心思想

此内存池的目标是提供一个类似 `malloc`/`free` 的通用接口，能够分配和释放**任意大小**的内存块，同时保持高性能。

它建立在之前最高性能的**线程本地缓存定长池**之上，并通过两种核心技术实现其通用性：

1.  **尺寸映射 (Size Classing)**：
    *   内部不再是单个池，而是维护一个包含多个定长内存池的数组（或向量）。
    *   每个定长池负责一个特定的“尺寸等级”。例如，池0负责8字节的块，池1负责16字节，池2负责32字节，以此类推，通常按2的幂次或某个固定步长递增。
    *   当用户请求分配 `size` 大小的内存时，系统会将其向上取整（round up）到最接近的尺寸等级，然后从对应的定长池中进行分配。
    *   对于超出预设最大尺寸（例如 512 字节）的大块内存请求，系统会回退（fallback）到调用全局的 `malloc`，避免在池中管理不常使用的大块内存。

2.  **元数据管理 (Metadata Management)**：
    *   一个关键问题是：当调用 `deallocate(ptr)` 时，系统如何知道 `ptr` 指向的内存块是多大，应该归还给哪个定长池？
    *   解决方案是在每次分配的内存块**头部**额外存储一小块元数据（`BlockHeader`）。
    *   这个 `Header` 中存放着一个指向其所属定长池的指针。
    *   `allocate` 返回给用户的地址是 `Header` 之后的数据区地址。
    *   `deallocate` 时，只需通过指针运算 `ptr - sizeof(Header)` 就能找到头部的元数据，从而获取到正确的池实例，并将内存块归还。
    *   对于通过 `malloc` 分配的大块内存，其 `Header` 中的池指针可以设为 `nullptr`，作为一个特殊标记。

## 优点

*   **接口通用**：提供了类似 `malloc` 的灵活接口，易于集成到现有代码中。
*   **高性能**：对于池管理范围内的常用小对象，它继承了线程本地缓存池的所有性能优势，分配和释放速度极快。

## 缺点

*   **内存开销 (Overhead)**：每个对象都带有一个额外的 `Header`，这会增加内存开销。对于非常小的对象（例如，分配8字节，但 `Header` 自身占8字节），开销率可能达到100%。
*   **内部碎片 (Internal Fragmentation)**：将请求尺寸向上取整会导致一定的内存浪费。例如，请求17字节的内存，但实际会分配一个32字节的块，其中15字节就被浪费了，这称为内部碎片。
