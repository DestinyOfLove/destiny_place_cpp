# 线程安全定长内存池 - Mutex 版本

## 核心思想

这是对 `FixedSizeMemoryPool` 的第一次迭代优化，主要目标是解决**线程安全**问题。

本版本采用最经典和直接的线程安全策略：**互斥锁 (Mutex)**。

1.  **引入 `std::mutex`**：在内存池类中增加一个 `std::mutex` 成员变量 `mutex_`。
2.  **加锁保护临界区**：在 `allocate()` 和 `deallocate()` 这两个修改共享资源（空闲链表 `free_list_head_`）的方法中，使用 `std::lock_guard<std::mutex>` 对代码块进行加锁。

`std::lock_guard` 利用了 C++ 的 RAII (Resource Acquisition Is Initialization) 特性，在构造时自动获取锁，在析构时（即离开作用域时）自动释放锁。这确保了即使在函数提前返回或抛出异常的情况下，锁也能被正确释放，避免了死锁问题。

## 优点

*   **简单可靠**：实现逻辑清晰、简单，易于理解和验证其正确性。
*   **绝对安全**：只要临界区被正确识别并完全覆盖，`std::mutex` 就能提供强大的安全保证，杜绝数据竞争。

## 缺点

*   **性能瓶颈**：互斥锁是一个重量级的同步原语。在高并发场景下，大量线程会因为等待锁而被阻塞，导致严重的性能瓶颈。所有线程对内存池的访问都被串行化了，无法真正利用多核处理器的优势。
*   **不区分读写**：即使某些操作理论上可以并发（例如，如果分离了分配和释放的计数器），互斥锁也会将它们全部阻塞。当然，在本实现中，分配和释放都修改了链表头，所以不存在这个问题。

这个版本是实现线程安全的基准，为后续更高性能的无锁版本提供了一个用于对比的参照物。
